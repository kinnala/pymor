import itertools
import json
import operator
import os
import sys
from contextlib import contextmanager
from functools import reduce
from pathlib import Path
from subprocess import check_output, CalledProcessError

import jinja2

REQUIRED_PLATFORMS = ('osx-64', 'linux-64', 'win-64')
# stars are not actually a glob pattern, but as-is in the conda search output
REQUIRED_PYTHONS = ('3.7.*', '3.9.*')
ANY_PYTHON_VERSION = 'any_python'
NO_PYTHON_VERSION = -1

ENV_TPL = r'''# THIS FILE IS AUTOGENERATED -- DO NOT EDIT #
name: pyMOR-ci
channels:
  - conda-forge
  - defaults
dependencies:
  - anaconda-client
  - pip
{% for pkg in available %}
  - {{pkg}}
{%- endfor %}

  - pip:
    - -r requirements-ci.txt
# THIS FILE IS AUTOGENERATED -- DO NOT EDIT #

'''

CONDA = '/home/rene/projekte/uni/pymor/conda/miniconda3/bin/conda'
# AFAICT we _should_ install pytorch-cpu instead of torch, that
# fails to install everywhere, so we're noping out of torch entirely
BLOCKLIST = ('torch', )
PYPI_TO_CONDA_PACKAGENAME_MAPPING = {'torch': 'pytorch-cpu'}


@contextmanager
def change_to_directory(name):
    """Change current working directory to `name` for the scope of the context."""
    old_cwd = os.getcwd()
    try:
        yield os.chdir(name)
    finally:
        os.chdir(old_cwd)


def _parse_req_file(path):
    path = Path(path).resolve()
    assert path.exists()
    assert path.is_file()
    pkgs = []
    with change_to_directory(path.parent):
        for line in open(path, 'rt').readlines():
            line = line.strip()
            if line.startswith('-r'):
                pkgs += _parse_req_file(line[line.find('-r ')+3:])
                continue
            if line.startswith('#'):
                continue
            if ';' in line:
                dropped = line.split(';')[0]
                print(f'Dropping chained specifier, using {dropped} instead of {line}')
                line = dropped
            name_only = _strip_markers(line)
            if name_only in BLOCKLIST:
                continue
            if name_only in PYPI_TO_CONDA_PACKAGENAME_MAPPING.keys():
                line = line.replace(name_only, PYPI_TO_CONDA_PACKAGENAME_MAPPING[name_only])
            pkgs.append(line)
    return pkgs


def _strip_markers(name):
    for m in '!;<>=':
        try:
            i = name.index(m)
            name = name[:i].strip()
        except ValueError:
            continue
    return name


def _search(pkg, plat):
    """Search needs to explicitly say it's subdir, else only the host's native is searched"""
    cmd = [CONDA, 'search', '--channel=conda-forge', '--json', f'{pkg}[subdir={plat}]']
    try:
        output = check_output(cmd)
    except CalledProcessError as e:
        if plat != 'noarch':
            print(f'Falling back to noarch for {pkg} - {plat}')
            return _search(pkg, 'noarch')
        try:
            err = json.loads(e.output)['error']
            if 'PackagesNotFoundError' in err:
                return []
            raise RuntimeError(err)
        except Exception:
            raise e

    pkg_name = _strip_markers(pkg).lower()
    out = json.loads(output)
    ll = list(itertools.chain.from_iterable((data for name, data in out.items() if name == pkg_name)))

    rr = list(reversed(ll))
    return rr


def _extract_conda_py(release):
    try:
        if release['package_type'] == 'noarch_python':
            return ANY_PYTHON_VERSION
    except KeyError:
        pass
    for pkg in release['depends']:
        if pkg.startswith('python_abi'):
            # format 'python_abi 3.9.* *_cp39'
            return pkg.split(' ')[1]
    return NO_PYTHON_VERSION


def _available_on_required(json_result, required_plats, required_pys):
    required_tuples = list(itertools.product(required_plats, required_pys))
    for release in json_result:
        plat = release['subdir']
        if plat not in required_plats and plat != 'noarch':
            continue
        py = _extract_conda_py(release)
        if py in required_pys or py == ANY_PYTHON_VERSION:
            covered_pys = [py] if py != ANY_PYTHON_VERSION else required_pys
            covered_plats = [plat] if plat != 'noarch' else required_plats
            to_remove = itertools.product(covered_plats, covered_pys)
            for pair in to_remove:
                try:
                    # combinations can be found multiple times
                    required_tuples.remove(pair)
                except ValueError as e:
                    if 'list.remove' in str(e):
                        continue
                    raise e
        if len(required_tuples) == 0:
            return True
    return False


def main(input_paths, output_path='environment.yml'):
    available = []
    for pkg in set(reduce(operator.concat, (_parse_req_file(p) for p in input_paths))):
        data = reduce(operator.concat, (_search(pkg, plat) for plat in REQUIRED_PLATFORMS))
        if _available_on_required(json_result=data,
                                  required_plats=REQUIRED_PLATFORMS,
                                  required_pys=REQUIRED_PYTHONS):
            available.append(pkg)
    tpl = jinja2.Template(ENV_TPL)
    with open(output_path, 'wt') as yml:
        yml.write(tpl.render(available=available))


if __name__ == '__main__':
    main(sys.argv[1:])
